Логика реализована в AIGroupManager, метод 
OnMoveCompleted() вызывается в EnemyAIController. 

Каждый кадр проверятся только расстояние от игрока до мяча.
Есди оно больше установленного числа = 
Минимальное расстояние от игрока до бота
+
Расстояние, на котором боту можно взять предмет
+
10
то все боты устремляются к предмету, чтобы взять.

Текущая цель ботов для достижения хранится в CurrentTarget.

Как только кто-то достиг предмета, он (в своём методе OnMoveCompleted)
говорит об этом менеджеру ИИ. 
	Если этот предмет - мяч:
Если у мяча ещё нет 
родителя, то менеджер говоритследующее:
-бот, достигший только что предмета, берёт предмет
-все боты останавливаются
-все боты бегут к игроку.

	Если этот предмет - игрок:
Тот говорит следующее:
-если у игрока есть возможность ходить - выключить
-всем ботам встать либо по кругу либо просто к игроку если неприменимо.

Как только все боты достигли своих позиций
(каждый бот по достижении говорит об этом менеджеру, 
тот их просто пересчитывает) , мяч сбрасывается и у игрока появляется 
возможность ходить.


В функциях, которые управляют отправкой ботов к позициям,
есть проверки на то, не двигается ли ещё бот.
Мне кажется, такой алгоритм является наиболее эффективным,
так как мы не проверяем лишний раз-каждый кадр-вообще ничего кроме
расстояния, то есть одного числа, что, как я считаю, не является лишним
и не нагружает компьютер. Остальное происходит с помощью
встроенного ивента OnMoveCompleted.

Еднственная проблема-боты иногда застревают друг в друге, 
но это вроде проблема не кода и не алгоритма, долго жонглировал 
настройками навигатора и модификаторов пути, что-то лучше работает,
что-то хуже. Попытаюсь довести это до конца.